//https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php
//http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl

#version 330
#pragma debug(on)
#pragma optimize(off)

in DATA {
	vec3 position;
	vec3 normal;
	vec2 uv;
} pass_data;

const float PI = 3.14159265f;

uniform float radius;
uniform vec3 cameraPosition;
uniform vec3 lightPosition;
uniform float ambientLight;

out vec4 out_Color;

vec2 random2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

vec2 sphere2mapUV_Equirectangular(vec3 p) {
	return vec2(atan(p.x, -p.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);
}

vec2 sphere2mapUV_EqualArea(vec3 p) {
	return vec2((atan(p.x, -p.z) / PI + 1.0) / 2.0, asin(p.y) / PI + 0.5);
}

vec2 toPolar(vec2 cartesian){
	float distance = length(cartesian);
	float angle = atan(cartesian.y, cartesian.x);
	return vec2(angle / PI * 2.0, distance);
}

void main(void) {	
	float height = length(pass_data.position) - radius;
	float maxHeight = 10.0; //TODO: define max-height like this?

	float heightGradient = height / maxHeight; 
 
 	float ambient = ambientLight;
	vec3 normal = pass_data.normal;
	vec3 lightDir = normalize(lightPosition - pass_data.position);
	float diffuse = max(dot(normal, lightDir), 0.0);

	// COLOR BORDERS
	float snow = 0.6;
	float stone = 0.2;
	float grass = 0.05;

	vec3 colorSand  = vec3( 0.89, 0.78, 0.41 );
	vec3 colorGrass = vec3( 0.22, 0.58, 0.28 );
	vec3 colorStone = vec3( 0.50, 0.56, 0.39 );
	vec3 colorSnow  = vec3( 0.87, 0.90, 0.89 );

	float mask1 = step(grass, heightGradient); 
	float mask2 = step(stone, heightGradient);
	float mask3 = step(snow, heightGradient);

	vec3 heightColor;
	heightColor = mix(colorSand, colorGrass, mask1);
	heightColor = mix(heightColor, colorStone, mask2);
	heightColor = mix(heightColor, colorSnow, mask3);

	float lightResult = ambient + diffuse;

	float heightLines = smoothstep(0.99, 1.0, sin(heightGradient * 80.0));
	heightColor *= (diffuse + ambient) - heightLines * 0.1;

//----------------------------------------------------------------
	// Scale
    vec2 st = sphere2mapUV_Equirectangular(normal) * 15.0;

    // Tile the space
    vec2 i_st = floor(st);
    vec2 f_st = fract(st);

	float m_dist = 1.0;  // minimum distance

	for (int y= -1; y <= 1; y++) {
        for (int x= -1; x <= 1; x++) {
            // Neighbor place in the grid
            vec2 neighbor = vec2(float(x),float(y));

            // Random position from current + neighbor place in the grid
            vec2 point = random2(i_st + neighbor);

			// Vector between the pixel and the point
            vec2 diff = neighbor + point - f_st;

            // Distance to the point
            float dist = length(diff);

            // Keep the closer distance
            m_dist = min(m_dist, dist);
        }
    }

	out_Color = vec4(heightColor, 1.0);
	
}